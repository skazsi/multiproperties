#summary How to implement new handler configurator class

= Introduction =

This page describes a possible way for implementing a handler configurator class. The goal of the example is still the same than it is described in the [ImplementingNewHandlerTutorial first part] of the tutorial. If you haven't read it, you should consider to do.

As it is already written in the [ImplementingNewHandlerTutorial first part] of the tutorial, we have the skeleton of the new handler, together with it's handler `class` and `configuratorClass` implementations, furthermore it is already visible for the MultiProperties plug-in, but it does not do anything. By the end of this wiki page, the handler configuration will be implemented. That means the new handler can be configured by the *Configure* button on the [FeaturesOfEditor#Columns Columns] page.

= Handler configuration =
When the MultiProperties is saved, the selected handler will be invoked for each column to do something. In this case it means the handler needs to write a text file for each column. The content of the text file depends not just on the current column content, but as it is described in the [ImplementingNewHandlerTutorial#Required_features required features] section, the _header_, _footer_ and the _body_ parts are customizable.

Because the MultiProperties format provides only a String based field for each column configuration, the example will uses the following format for storing the handler configuration for each column.
{{{
path\/header\/property\/comment\/empty\/footer
}}}
The above seen format uses the backslash `\` and slash `/` characters together as field separator.

== Configurator implementations ==
Create a new `hu.skzs.multiproperties.handler.text.configurator` package for handler configuration codes. First of all, we need a _configurator_ class for *formatting* and *parsing* the above seen configuration format. But when we use the handler from [CommandLineHandlerExecutor command line], then the `path` part of the configuration means a *file system* location instead of Eclipse *workspace* location. That means we need two different implementations, and of course a factory class which is able to choose the proper implementation.

=== Configurator classes ===
See below the `AbstractConfigurator` class. Please note that the constructor will parse the String based configuration, and the `toString` method will format it. Furthermore at this point we cannot know whether the plug-in is used from [CommandLineHandlerExecutor command line] or not, the implementation is abstract together with the abstract `parsePath` and `formatPath` methods.

Finally you need to implement the missing getter and setter methods for `headerPattern`, `footerPattern`, `propertyPattern`, `commentPattern`, `emptyPattern` fields. You need to implemented them.
<code language="java">package hu.skzs.multiproperties.handler.text.configurator;

import hu.skzs.multiproperties.handler.text.writer.WriterConfigurationException;

import java.util.StringTokenizer;

public abstract class AbstractConfigurator {
    protected static final String DELIM = "\\/";

    protected String headerPattern;
    protected String footerPattern;
    protected String propertyPattern;
    protected String commentPattern;
    protected String emptyPattern;

    public AbstractConfigurator(final String configuration) throws WriterConfigurationException {
        if (configuration == null || configuration.equals(""))
            return;
        try {
            final StringTokenizer tokenizer = new StringTokenizer(configuration, DELIM);
            parsePath(tokenizer.nextToken());
            headerPattern = tokenizer.nextToken();
            propertyPattern = tokenizer.nextToken();
            commentPattern = tokenizer.nextToken();
            emptyPattern = tokenizer.nextToken();
            footerPattern = tokenizer.nextToken();
        }
        catch (final Exception e) {
            throw new WriterConfigurationException("Unexpected error occurred during parsing the handler configuration", e);
        }
    }

    @Override
    public String toString() {
        final StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(formatPath());
        stringBuilder.append(DELIM);
        stringBuilder.append(headerPattern);
        stringBuilder.append(DELIM);
        stringBuilder.append(propertyPattern);
        stringBuilder.append(DELIM);
        stringBuilder.append(commentPattern);
        stringBuilder.append(DELIM);
        stringBuilder.append(emptyPattern);
        stringBuilder.append(DELIM);
        stringBuilder.append(footerPattern);
        return stringBuilder.toString();
    }

    public abstract void parsePath(String path);

    public abstract String formatPath();

    // FIXME: create all of the getter and setter methods for headerPattern, propertyPattern, commentPattern, emptyPattern and footerPattern fields
}
</code>
The `WorkspaceConfigurator` class is the Eclipse workspace based implementation of `AbstractConfigurator` class. You need to implement the missing getter and setter methods again for `containerName` and `fileName` fields.
<code language="java">
package hu.skzs.multiproperties.handler.text.configurator;

import hu.skzs.multiproperties.handler.text.writer.WriterConfigurationException;

public class WorkspaceConfigurator extends AbstractConfigurator {

    private String containerName;
    private String fileName;

    public WorkspaceConfigurator(final String configuration) throws WriterConfigurationException {
        super(configuration);
    }

    @Override
    public void parsePath(final String path)
    {
        containerName = path.substring(0, path.lastIndexOf("/"));
        fileName = path.substring(path.lastIndexOf("/") + 1);
    }

    @Override
    public String formatPath()
    {
        final StringBuilder stringBuilder = new StringBuilder(containerName);
        stringBuilder.append("/");
        stringBuilder.append(fileName);
        return stringBuilder.toString();
    }

    // FIXME: create all of the getter and setter methods for containerName and fileName fields

}
</code>
The `FileSystemConfigurator` class is the file system based implementation of `AbstractConfigurator` class. You need to implement the missing getter and setter methods again for `fileName` field.
<code language="java">
package hu.skzs.multiproperties.handler.text.configurator;

import hu.skzs.multiproperties.handler.text.writer.WriterConfigurationException;

public class FileSystemConfigurator extends AbstractConfigurator {

    private String fileName;

    public FileSystemConfigurator(final String configuration) throws WriterConfigurationException {
        super(configuration);
    }

    @Override
    public void parsePath(final String path) {
        fileName = path;
    }

    @Override
    public String formatPath() {
        return fileName;
    }

    // FIXME: create the getter and setter methods for fileName fields
}

</code>
